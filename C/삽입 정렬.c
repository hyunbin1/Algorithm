/* 삽입정렬: 시간 복잡도 = O(N*N) 
각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결한다. 
따라서 선택, 버블 정렬과 달리 필요할때만 위치를 바꾸기 때문에 같은 시간 복잡도여도 보다 빠르다. 

Q. array[10] = {1,10,5,8,7,2,4,3,9,6}
사고의 과정 [
첫번째 돌때 : 10이 _1_ (1의 오른쪽 왼쪽) 둘 중 어디에 들어가야 되는지 생각한다
두번째 돌때 : _1_10_ (5가 1의 왼쪽, 1과 10 사이, 맨 왼쪽) 셋 중 어디에 들어가야 되는지 생각한다. 
세번째 돌때 : _1_5_10_ (8이 _ 중 어디에 들어갈지 생각한다.)
...
마지막: _1_2_3_4_5_7_8_9_10_ 중 6이 들어갈 자리를 찾는다.
= 앞에 있는 것들은 벌써 정리가 되어 있음. 
]

코드의 과정 :
만일 1,4,5,6,7,8,9,10,2,3이 있다면
1,4,5,6,7,8,9,2,10,3 -> 1,4,5,6,7,8,2,9,10,3 -> 1,4,5,6,7,2,8,9,10,3
이런 식으로 옆에 있는 것들과 값을 비교해가며 바꿔준다. 

*/
#include <stdio.h>

int main(void)
{
    int j, temp;
    int array[10] = {1, 10, 3, 8, 7, 6, 5, 4, 9, 2};
    for (j = 0; j < 10; j++)
    {
        while (array[j] > array[j + 1])
        {
            temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
            // j가 0이 되면 멈춤
            j--;
        }
    }
    for (j = 0; j < 10; j++)
    {
        printf("%d ", array[j]);
    }
    return 0;
}

// 반복문이 for, while에서 두번 사용했다는 점에서 버블 정렬과 선택정렬과 같은 시간 복잡도를 가진다. O(N*N)
// 하지만 거의 정렬된 상태라면 삽입 정렬이 가장 효율적이다.