#include <stdio.h>

// 선택 정렬 알고리즘 = 가장 작은 것을 선택하여 앞으로 보낸다.
// 문제 1. [1,3,4,5,8,7,6,9,2,10]을 오름차순으로 실행

int main(void)
{
    // 만약에 10개 중에 최소값을 1번만 찾으면 된다면 우리는 i만 사용하면 된다.
    // 하지만 우리가 원하는 것은 1~10, 2~10, 3~10, ~, 10 까지 일일히 다 탐색을 해보는 것이다. 따라서,
    // i에서는 j의 시작점을 인도해주는 역할이다. 즉 원소의 총 개수.
    // j = i부터 시작하여 배열에 있는 원소들을 반복적으로 탐색하기 위해 사용
    // min = 가장 작은 수를 반복적으로 선택하기 위해 사용
    // index = 가장 작은 것이 존재하는 위치 (정답지 형성)
    // temp  = 특정한 두 숫자를 서로 바꾸기 위해 사용
    int i, j, min, index, temp;
    // 원소의 개수를 10개라고 가정하고 문제를 생성해줌(1~10의 무작위 배열) :
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
    // i를 0~10까지 반복:(정답을 넣을 공간 만들기)
    for (i = 1; i < 10; i++)
    {
        // min에 모든 원소들보다 큰 수를 넣어준다. 항상 최소값을 넣어줘야되기 때문에 처음에는 제일 큰 값을 넣어줘야되기 때문이다.
        min = 100;

        for (j = i; j < 10; j++)
        {
            if (array[j] < min)
            {
                //min에 array[j]를 넣어준다는 것은 이때 j의 값을 정해주는것이 전제로 깔려있다. 예를 들어 3번째 것이 가장 작다면 j는 3이 되는 것이다.
                min = array[j];
                // min을 어디에 넣어줄 것인가? - 1~10을 모두 탐색한 결과라면 이것은 가장 작은 값일 것이다.
                // index에 해당 위치 값을 넣어준다.
                index = j;
            }
        }

        // 스와핑: temp와 index를 사용하지 않으면, [1,2,3,5]에서 1,5를 서로 교환Y고 싶어도 [5,2,3,5]가 되기 때문에 4번째 5에 1을 바꿔줄 수가 없다.
        //- array[i]의 기존 값은 유지한 체로 새로운 변수 temp에 array[i]값을 넣어준다음에 진짜 array[i]는 교체를 해주고
        //옆에 잠깐 저장해둔 temp를 사용해서 array[j]와 교체해줘서 1과 5가 서로 교환이 가능하게 하는 것이다  */

        // 만약 array[j]를 사용했다면, j의 값은 기존 i의 값으로 갈 것이다. 만약에 i가 일이였다면 j는 1이 된다.
        temp = array[i];
        array[i] = array[index];
        array[index] = temp;
        // index대신 j를 넣게 되면, 1,7,5,10,5,8,7,6,4,3,2
    }
    for (i = 0; i < 10; i++)
    {
        printf("%d ", array[i]);
    }
    return 0;
}

// 선택정렬의 시간 복잡도 = O(N*N) = 비효율적
/* 선택정렬의 계산 횟수는 10+9+8+..+1 = 10*(10+1)/2 = 55이다.
이를 일반화 하면 N(N+1)/2이다. 
하지만 일반적으로 시간 복잡도는 N의 수가 매우 크기 때문에, 단순한 더하기와 나누기는 무시한다. 
따라서 빅오(O)표기법에 따르면 선택정렬의 시간 복잡도는
O(N*N)가 된다. 이는 O(n^2)와 같다. 
이차곡선인 N의 제곱은 x의 값이 조금만 변화해도 y값의 크기가 매우 커지기 때문에
매우 비효율적인 시간 복잡도라고 할 수 있다. 
*/
