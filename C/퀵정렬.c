#include <stdio.h>
/*! 퀵 정렬: 버블, 선택, 삽입 정렬 방법과 달리 매우 빠른 정렬 알고리즘이다. 
 이는 대표적인 '분할 정복'알고리즘으로, 평균 속도가 O(N*logN)이다. 이는 사실상 상수라고 할 수 있음. 
 대부분에서는 좋은 시간 복잡도를 가지지만 최악의 경우 O(N*N)까지 나오게 된다. 

 문제는 동일 - 오름차순 정리
 방법: 특정한 값을 기준으로 큰 숫자와 작은 숫자를 반으로, 두 집합으로 나눈다. 
  == 피벗(=기준)을 생성해주는 것 - 보통 맨 앞의 값을 피벗값으로 설정한다.
  #3,7,8,1,5,9,6,10,2,4 에서 왼쪽에서 오른쪽으로는 피벗값(3)보다 큰 수를 찾고 맨 오른쪽에서 왼쪽으로는 피벗값보다 작은 수를 찾는다. 그다음 서로의 값을 바꿔준다. //7,2
  #3,2,8,1,5,9,6,10,7,4  // 8,1 -> 
  #3,2,1,8,5,9,6,10,7,4  // 1,8 = 엇갈림: 작은 값자리 수(오른쪽에서 왼쪽)가 큰값자리에 있는 수(왼쪽에서 오른족)보다 큼 => 큰값인덱스(왼쪽의 값)와 피벗값을 바꿔준다, 즉 1과 3을 바꿔준다. 
  1,2,#3,8,5,9,6,10,7,4 // 3기준 정렬은 이루어짐 => 새로운 피벗값을 만들기 = 맨앞 =1
  #1,2,#3,8,5,9,6,10,7,4 // 2,1 ==  새로운 피벗 찾기 = 1,3을 제외하고 가장 앞에 있는 것 = 2
  #1,#2,#3,8,5,9,6,10,7,4 // 2도 엇갈림 -> 피벗 = 8
  #1,#2,#3,#8,5,9,6,10,7,4 // 9,4
  #1,#2,#3,#8,5,4,6,10,7,9 // 10,7
  #1,#2,#3,#8,5,4,6,7,10,9 // 엇갈림 -> 8,5를 바꿔준다 ->피벗 7
  #1,#2,#3,#7,5,4,6,#8,10,9 // 피벗 8이 있기 때문에 피벗이 7인경우에는 7546만 탐색한다. 엇갈림 = x,6 -> 피벗 6
  #1,#2,#3,#6,5,4,#7,#8,10,9 // 엇갈림 = X,4 -> 피벗 4
  #1,#2,#3,#4,5,#6,#7,#8,10,9 // 엇갈림 = 5,4 -> 피벗 5 
  #1,#2,#3,#4,#5,#6,#7,#8,10,9 // 엇갈림 5,5 ->피벗 = 10
  #1,#2,#3,#4,#5,#6,#7,#8,#10,9 //엇갈림
  #1,#2,#3,#4,#5,#6,#7,#8,9,#10끝

  작동 계산: 
  선택, 버블, 삽입정렬 = 10*10 ==> N*N
  퀵정렬: [12345 -> 5*5, 678910 -> 5*5] => 25+25 = 50 ==> 데이터의 개수 N * N을 반씩 쪼갠 logN => O(N*log2의N)
*/

// 재귀함수
int number = 10;
//데이터:
int data[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
// 퀵 정렬 함수 만들기
void quickSort(int *data, int start, int end)
{
    // 부분 집합의 첫번째 = start, 마지막= end => start가 end보다 크거나 같다는 것은 원소가 하나임을 의미
    if (start >= end)
    {
        return;
    }
    //피벗값
    int key = start; // 키값(피벗값)은 첫번째 원소
    // i 는 왼쪽부터 오른쪽으로 피벗값보다 큰 값을 찾기
    int i = start + 1;
    // j는 오른쪽 출발지점 = 피벗보다 작은 값 찾기.
    int j = end;
    // temp = 스와핑을 위한 임시 변수
    int temp;
    //엇갈리기 전까지 작동하기
    while (i <= j)
    {
        while (data[i] <= data[key])
        {
            i++;
        }
        // j>start이유는 엇갈릴시 j와 key값을 교체해 주기 때문에 j값이 start보다 왼쪽으로 넘어가 주지만 않으면 되기 때문이다.
        while (data[j] >= data[key] && j > start)
        {
            j--;
        }

        if (i > j) // 엇갈렸다면 j와 key값을 바꿔줌 => i의 값이 아니라 i와 j의 순서이다.
        {
            temp = data[j];
            data[j] = data[key];
            data[key] = temp;
        }
        else
        { // 엇갈리지 않았을땐 i와 j바꿔주기
            temp = data[j];
            data[j] = data[i];
            data[i] = temp;
        }
    }
    //? #1,#2,#3,#7,5,4,6,#8,10,9 // 피벗 8이 있기 때문에 피벗이 7인경우에는 7546만 탐색한다. 엇갈림 = x,6 -> 피벗 6
    // (start, j-1) == 546 , (j+1 , end) = 10, 9
    quickSort(data, start, j - 1);
    quickSort(data, j + 1, end);
}

int main(void)
{ //index 0 부터 9까지 정렬
    quickSort(data, 0, number - 1);
    for (int i = 0; i < number; i++)
    {
        printf("%d ", data[i]);
    }
}

/* 퀵정렬 시간 복잡도 최악인 경우:
    12345678910 일 경우에는 분할할 수 있다는 이점을 사용하지 못하기 때문에 10(1~10)+9(2~10)+8 ... 을 계산하게 된다.
    1이 피벗일 시에 10~ 1까지 1보다 작은 값을 찾지 못하기 때문에 10~1까지 모두 탐색을 해야된다. 

*/